[ ](https://ziglang.org/documentation/master/std/)
  * [std](https://ziglang.org/documentation/master/std/#std)
  * [multi_array_list](https://ziglang.org/documentation/master/std/#std.multi_array_list)
  * [MultiArrayList](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList)


Loading...
# Type Function[[src]](https://ziglang.org/documentation/master/std/#src/std/multi_array_list.zig)
A MultiArrayList stores a list of a struct or tagged union type. Instead of storing a single list of items, MultiArrayList stores separate lists for each field of the struct or lists of tags and bare unions. This allows for memory savings if the struct or union has padding, and also improves cache usage if only some fields or just tags are needed for a computation. The primary API for accessing fields is the `slice()` function, which computes the start pointers for the array of each field. From the slice you can call `.items(.<field_name>)` to obtain a slice of field values. For unions you can call `.items(.tags)` or `.items(.data)`.
## Parameters
```
T: type
```

## Errors
anyerror means the error set is known only at runtime.
## Search Results
## No Results Found
Press escape to exit search and then '?' to see more options.
## Fields
```
bytes: [*]align(@alignOf(T)) u8 = undefined
```

```
len: usize = 0
```

```
capacity: usize = 0
```

## Types
  * [Field](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.Field)
  * [Slice](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.Slice)


## Namespaces
## Global Variables
## Values
[empty](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.empty)| `Self[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList)`|   
---|---|---  
## Functions `pub fn addOne[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.addOne)(self: *Self[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList), gpa: Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator)) Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator).Error[](https://ziglang.org/documentation/master/std/#std.mem.Allocator.Error)!usize`
    
Extend the list by 1 element, returning the newly reserved index with uninitialized data. Allocates more memory as necesasry. `pub fn addOneAssumeCapacity[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.addOneAssumeCapacity)(self: *Self[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList)) usize`
    
Extend the list by 1 element, asserting `self.capacity` is sufficient to hold an additional item. Returns the newly reserved index with uninitialized data. `pub fn append[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.append)(self: *Self[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList), gpa: Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator), elem: T) !void`
    
Extend the list by 1 element. Allocates more memory as necessary. `pub fn appendAssumeCapacity[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.appendAssumeCapacity)(self: *Self[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList), elem: T) void`
    
Extend the list by 1 element, but asserting `self.capacity` is sufficient to hold an additional item. `pub fn capacityInBytes[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.capacityInBytes)(capacity: usize) usize`
`pub fn clearAndFree[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.clearAndFree)(self: *Self[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList), gpa: Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator)) void`
`pub fn clearRetainingCapacity[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.clearRetainingCapacity)(self: *Self[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList)) void`
    
Invalidates all element pointers. `pub fn clone[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.clone)(self: Self[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList), gpa: Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator)) !Self[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList)`
    
Create a copy of this list with a new backing store, using the specified allocator. `pub fn deinit[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.deinit)(self: *Self[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList), gpa: Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator)) void`
    
Release all allocated memory. `pub fn ensureTotalCapacity[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.ensureTotalCapacity)(self: *Self[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList), gpa: Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator), new_capacity: usize) Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator).Error[](https://ziglang.org/documentation/master/std/#std.mem.Allocator.Error)!void`
    
Modify the array so that it can hold at least `new_capacity` items. Implements super-linear growth to achieve amortized O(1) append operations. Invalidates element pointers if additional memory is needed. `pub fn ensureUnusedCapacity[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.ensureUnusedCapacity)(self: *Self[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList), gpa: Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator), additional_count: usize) !void`
    
Modify the array so that it can hold at least `additional_count` **more** items. Invalidates pointers if additional memory is needed. `pub fn get[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.get)(self: Self[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList), index: usize) T`
    
Obtain all the data for one array element. `pub fn insert[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.insert)(self: *Self[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList), gpa: Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator), index: usize, elem: T) !void`
    
Inserts an item into an ordered list. Shifts all elements after and including the specified index back by one and sets the given index to the specified element. May reallocate and invalidate iterators. `pub fn insertAssumeCapacity[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.insertAssumeCapacity)(self: *Self[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList), index: usize, elem: T) void`
    
Inserts an item into an ordered list which has room for it. Shifts all elements after and including the specified index back by one and sets the given index to the specified element. Will not reallocate the array, does not invalidate iterators. `pub fn items[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.items)(self: Self[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList), comptime field: Field[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.Field)) []FieldType[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.FieldType)(field)`
    
Get the slice of values for a specified field. If you need multiple fields, consider calling slice() instead. `pub fn orderedRemove[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.orderedRemove)(self: *Self[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList), index: usize) void`
    
Remove the specified item from the list, shifting items after it to preserve order. `pub fn pop[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.pop)(self: *Self[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList)) ?T`
    
Remove and return the last element from the list, or return `null` if list is empty. Invalidates pointers to fields of the removed element. `pub fn resize[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.resize)(self: *Self[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList), gpa: Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator), new_len: usize) !void`
    
Adjust the list's length to `new_len`. Does not initialize added items, if any. `pub fn set[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.set)(self: *Self[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList), index: usize, elem: T) void`
    
Overwrite one array element with new data. `pub fn setCapacity[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.setCapacity)(self: *Self[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList), gpa: Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator), new_capacity: usize) !void`
    
Modify the array so that it can hold exactly `new_capacity` items. Invalidates pointers if additional memory is needed. `new_capacity` must be greater or equal to `len`. `pub fn shrinkAndFree[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.shrinkAndFree)(self: *Self[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList), gpa: Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator), new_len: usize) void`
    
Attempt to reduce allocated capacity to `new_len`. If `new_len` is greater than zero, this may fail to reduce the capacity, but the data remains intact and the length is updated to new_len. `pub fn shrinkRetainingCapacity[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.shrinkRetainingCapacity)(self: *Self[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList), new_len: usize) void`
    
Reduce length to `new_len`. Invalidates pointers to elements `items[new_len..]`. Keeps capacity the same. `pub fn slice[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.slice)(self: Self[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList)) Slice[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.Slice)`
    
Compute pointers to the start of each field of the array. If you need to access multiple fields, calling this may be more efficient than calling `items()` multiple times. `pub fn sort[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.sort)(self: Self[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList), ctx: anytype) void`
    
This function guarantees a stable sort, i.e the relative order of equal elements is preserved during sorting. Read more about stable sorting here: <https://en.wikipedia.org/wiki/Sorting_algorithm#Stability> If this guarantee does not matter, `sortUnstable` might be a faster alternative. `ctx` has the following method: `fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool` `pub fn sortSpan[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.sortSpan)(self: Self[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList), a: usize, b: usize, ctx: anytype) void`
    
Sorts only the subsection of items between indices `a` and `b` (excluding `b`) This function guarantees a stable sort, i.e the relative order of equal elements is preserved during sorting. Read more about stable sorting here: <https://en.wikipedia.org/wiki/Sorting_algorithm#Stability> If this guarantee does not matter, `sortSpanUnstable` might be a faster alternative. `ctx` has the following method: `fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool` `pub fn sortSpanUnstable[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.sortSpanUnstable)(self: Self[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList), a: usize, b: usize, ctx: anytype) void`
    
Sorts only the subsection of items between indices `a` and `b` (excluding `b`) This function does NOT guarantee a stable sort, i.e the relative order of equal elements may change during sorting. Due to the weaker guarantees of this function, this may be faster than the stable `sortSpan` method. Read more about stable sorting here: <https://en.wikipedia.org/wiki/Sorting_algorithm#Stability> `ctx` has the following method: `fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool` `pub fn sortUnstable[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.sortUnstable)(self: Self[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList), ctx: anytype) void`
    
This function does NOT guarantee a stable sort, i.e the relative order of equal elements may change during sorting. Due to the weaker guarantees of this function, this may be faster than the stable `sort` method. Read more about stable sorting here: <https://en.wikipedia.org/wiki/Sorting_algorithm#Stability> `ctx` has the following method: `fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool` `pub fn swapRemove[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.swapRemove)(self: *Self[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList), index: usize) void`
    
Remove the specified item from the list, swapping the last item in the list into its position. Fast, but does not retain list ordering. `pub fn toOwnedSlice[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.toOwnedSlice)(self: *Self[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList)) Slice[](https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.Slice)`
    
The caller owns the returned memory. Empties this MultiArrayList.
## Error Sets
## Example Usage
## Source Code
# Keyboard Shortcuts 

`?`
    Show this help dialog 

`Esc`
    Clear focus; close this dialog 

`s`
    Focus the search field 

`u`
    Go to source code 

`↑`
    Move up in search results 

`↓`
    Move down in search results 

`⏎`
    Go to active search result
# Errors
