[ ](https://ziglang.org/documentation/master/std/)
  * [std](https://ziglang.org/documentation/master/std/#std)
  * [hash_map](https://ziglang.org/documentation/master/std/#std.hash_map)
  * [AutoHashMapUnmanaged](https://ziglang.org/documentation/master/std/#std.hash_map.AutoHashMapUnmanaged)


Loading...
# Type Function[[src]](https://ziglang.org/documentation/master/std/#src/std/hash_map.zig)
## Parameters
```
K: type
```

```
V: type
```

## Errors
anyerror means the error set is known only at runtime.
## Search Results
## No Results Found
Press escape to exit search and then '?' to see more options.
## Fields
```
metadata: ?[*]Metadata[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.Metadata) = null
```

Pointer to the metadata.
```
size: Size[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.Size) = 0
```

Current number of elements in the hashmap.
```
available: Size[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.Size) = 0
```

Number of available slots before a grow is needed to satisfy the `max_load_percentage`.
```
pointer_stability: std[](https://ziglang.org/documentation/master/std/#std).debug[](https://ziglang.org/documentation/master/std/#std.debug).SafetyLock[](https://ziglang.org/documentation/master/std/#std.debug.SafetyLock) = .{}
```

Used to detect memory safety violations.
## Types
  * [Entry](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.Entry)
  * [GetOrPutResult](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.GetOrPutResult)
  * [Hash](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.Hash)
  * [Iterator](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.Iterator)
  * [KV](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.KV)
  * [KeyIterator](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.KeyIterator)
  * [Managed](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.Managed)
  * [Size](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.Size)
  * [ValueIterator](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.ValueIterator)


## Namespaces
## Global Variables
## Values
[empty](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.empty)| `Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged)`| A map containing no keys or values.  
---|---|---  
## Functions `pub fn capacity[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.capacity)(self: Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged)) Size[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.Size)`
`pub fn clearAndFree[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.clearAndFree)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), allocator: Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator)) void`
`pub fn clearRetainingCapacity[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.clearRetainingCapacity)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged)) void`
`pub fn clone[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.clone)(self: Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), allocator: Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator)) Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator).Error[](https://ziglang.org/documentation/master/std/#std.mem.Allocator.Error)!Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged)`
`pub fn cloneContext[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.cloneContext)(self: Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), allocator: Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator), new_ctx: anytype) Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator).Error[](https://ziglang.org/documentation/master/std/#std.mem.Allocator.Error)!HashMapUnmanaged[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged)(K, V, @TypeOf(new_ctx), max_load_percentage)`
`pub fn contains[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.contains)(self: Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), key: K) bool`
    
Return true if there is a value associated with key in the map. `pub fn containsAdapted[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.containsAdapted)(self: Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), key: anytype, ctx: anytype) bool`
`pub fn containsContext[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.containsContext)(self: Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), key: K, ctx: Context) bool`
`pub fn count[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.count)(self: Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged)) Size[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.Size)`
`pub fn deinit[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.deinit)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), allocator: Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator)) void`
`pub fn ensureTotalCapacity[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.ensureTotalCapacity)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), allocator: Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator), new_size: Size[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.Size)) Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator).Error[](https://ziglang.org/documentation/master/std/#std.mem.Allocator.Error)!void`
`pub fn ensureTotalCapacityContext[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.ensureTotalCapacityContext)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), allocator: Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator), new_size: Size[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.Size), ctx: Context) Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator).Error[](https://ziglang.org/documentation/master/std/#std.mem.Allocator.Error)!void`
`pub fn ensureUnusedCapacity[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.ensureUnusedCapacity)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), allocator: Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator), additional_size: Size[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.Size)) Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator).Error[](https://ziglang.org/documentation/master/std/#std.mem.Allocator.Error)!void`
`pub fn ensureUnusedCapacityContext[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.ensureUnusedCapacityContext)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), allocator: Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator), additional_size: Size[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.Size), ctx: Context) Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator).Error[](https://ziglang.org/documentation/master/std/#std.mem.Allocator.Error)!void`
`pub fn fetchPut[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.fetchPut)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), allocator: Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator), key: K, value: V) Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator).Error[](https://ziglang.org/documentation/master/std/#std.mem.Allocator.Error)!?KV[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.KV)`
    
Inserts a new `Entry` into the hash map, returning the previous one, if any. `pub fn fetchPutAssumeCapacity[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacity)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), key: K, value: V) ?KV[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.KV)`
    
Inserts a new `Entry` into the hash map, returning the previous one, if any. If insertion happens, asserts there is enough capacity without allocating. `pub fn fetchPutAssumeCapacityContext[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.fetchPutAssumeCapacityContext)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), key: K, value: V, ctx: Context) ?KV[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.KV)`
`pub fn fetchPutContext[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.fetchPutContext)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), allocator: Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator), key: K, value: V, ctx: Context) Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator).Error[](https://ziglang.org/documentation/master/std/#std.mem.Allocator.Error)!?KV[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.KV)`
`pub fn fetchRemove[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.fetchRemove)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), key: K) ?KV[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.KV)`
    
If there is an `Entry` with a matching key, it is deleted from the hash map, and then returned from this function. `pub fn fetchRemoveAdapted[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.fetchRemoveAdapted)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), key: anytype, ctx: anytype) ?KV[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.KV)`
`pub fn fetchRemoveContext[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.fetchRemoveContext)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), key: K, ctx: Context) ?KV[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.KV)`
`pub fn get[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.get)(self: Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), key: K) ?V`
    
Get a copy of the value associated with key, if present. `pub fn getAdapted[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.getAdapted)(self: Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), key: anytype, ctx: anytype) ?V`
`pub fn getContext[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.getContext)(self: Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), key: K, ctx: Context) ?V`
`pub fn getEntry[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.getEntry)(self: Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), key: K) ?Entry[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.Entry)`
`pub fn getEntryAdapted[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.getEntryAdapted)(self: Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), key: anytype, ctx: anytype) ?Entry[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.Entry)`
`pub fn getEntryContext[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.getEntryContext)(self: Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), key: K, ctx: Context) ?Entry[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.Entry)`
`pub fn getKey[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.getKey)(self: Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), key: K) ?K`
    
Get a copy of the actual key associated with adapted key, if present. `pub fn getKeyAdapted[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.getKeyAdapted)(self: Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), key: anytype, ctx: anytype) ?K`
`pub fn getKeyContext[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.getKeyContext)(self: Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), key: K, ctx: Context) ?K`
`pub fn getKeyPtr[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.getKeyPtr)(self: Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), key: K) ?*K`
    
Get an optional pointer to the actual key associated with adapted key, if present. `pub fn getKeyPtrAdapted[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.getKeyPtrAdapted)(self: Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), key: anytype, ctx: anytype) ?*K`
`pub fn getKeyPtrContext[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.getKeyPtrContext)(self: Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), key: K, ctx: Context) ?*K`
`pub fn getOrPut[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.getOrPut)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), allocator: Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator), key: K) Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator).Error[](https://ziglang.org/documentation/master/std/#std.mem.Allocator.Error)!GetOrPutResult[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.GetOrPutResult)`
`pub fn getOrPutAdapted[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.getOrPutAdapted)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), allocator: Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator), key: anytype, key_ctx: anytype) Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator).Error[](https://ziglang.org/documentation/master/std/#std.mem.Allocator.Error)!GetOrPutResult[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.GetOrPutResult)`
`pub fn getOrPutAssumeCapacity[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacity)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), key: K) GetOrPutResult[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.GetOrPutResult)`
`pub fn getOrPutAssumeCapacityAdapted[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityAdapted)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), key: anytype, ctx: anytype) GetOrPutResult[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.GetOrPutResult)`
`pub fn getOrPutAssumeCapacityContext[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.getOrPutAssumeCapacityContext)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), key: K, ctx: Context) GetOrPutResult[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.GetOrPutResult)`
`pub fn getOrPutContext[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.getOrPutContext)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), allocator: Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator), key: K, ctx: Context) Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator).Error[](https://ziglang.org/documentation/master/std/#std.mem.Allocator.Error)!GetOrPutResult[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.GetOrPutResult)`
`pub fn getOrPutContextAdapted[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.getOrPutContextAdapted)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), allocator: Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator), key: anytype, key_ctx: anytype, ctx: Context) Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator).Error[](https://ziglang.org/documentation/master/std/#std.mem.Allocator.Error)!GetOrPutResult[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.GetOrPutResult)`
`pub fn getOrPutValue[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.getOrPutValue)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), allocator: Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator), key: K, value: V) Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator).Error[](https://ziglang.org/documentation/master/std/#std.mem.Allocator.Error)!Entry[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.Entry)`
`pub fn getOrPutValueContext[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.getOrPutValueContext)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), allocator: Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator), key: K, value: V, ctx: Context) Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator).Error[](https://ziglang.org/documentation/master/std/#std.mem.Allocator.Error)!Entry[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.Entry)`
`pub fn getPtr[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.getPtr)(self: Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), key: K) ?*V`
    
Get an optional pointer to the value associated with key, if present. `pub fn getPtrAdapted[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.getPtrAdapted)(self: Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), key: anytype, ctx: anytype) ?*V`
`pub fn getPtrContext[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.getPtrContext)(self: Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), key: K, ctx: Context) ?*V`
`pub fn iterator[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.iterator)(self: *const Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged)) Iterator[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.Iterator)`
`pub fn keyIterator[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.keyIterator)(self: Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged)) KeyIterator[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.KeyIterator)`
`pub fn lockPointers[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.lockPointers)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged)) void`
    
Puts the hash map into a state where any method call that would cause an existing key or value pointer to become invalidated will instead trigger an assertion. `pub fn move[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.move)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged)) Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged)`
    
Set the map to an empty state, making deinitialization a no-op, and returning a copy of the original. `pub fn promote[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.promote)(self: Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), allocator: Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator)) Managed[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.Managed)`
`pub fn promoteContext[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.promoteContext)(self: Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), allocator: Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator), ctx: Context) Managed[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.Managed)`
`pub fn put[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.put)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), allocator: Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator), key: K, value: V) Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator).Error[](https://ziglang.org/documentation/master/std/#std.mem.Allocator.Error)!void`
    
Insert an entry if the associated key is not already present, otherwise update preexisting value. `pub fn putAssumeCapacity[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.putAssumeCapacity)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), key: K, value: V) void`
    
Asserts there is enough capacity to store the new key-value pair. Clobbers any existing data. To detect if a put would clobber existing data, see `getOrPutAssumeCapacity`. `pub fn putAssumeCapacityContext[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.putAssumeCapacityContext)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), key: K, value: V, ctx: Context) void`
`pub fn putAssumeCapacityNoClobber[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobber)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), key: K, value: V) void`
    
Insert an entry in the map. Assumes it is not already present, and that no allocation is needed. `pub fn putAssumeCapacityNoClobberContext[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.putAssumeCapacityNoClobberContext)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), key: K, value: V, ctx: Context) void`
`pub fn putContext[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.putContext)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), allocator: Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator), key: K, value: V, ctx: Context) Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator).Error[](https://ziglang.org/documentation/master/std/#std.mem.Allocator.Error)!void`
`pub fn putNoClobber[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.putNoClobber)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), allocator: Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator), key: K, value: V) Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator).Error[](https://ziglang.org/documentation/master/std/#std.mem.Allocator.Error)!void`
    
Insert an entry in the map. Assumes it is not already present. `pub fn putNoClobberContext[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.putNoClobberContext)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), allocator: Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator), key: K, value: V, ctx: Context) Allocator[](https://ziglang.org/documentation/master/std/#std.mem.Allocator).Error[](https://ziglang.org/documentation/master/std/#std.mem.Allocator.Error)!void`
`pub fn rehash[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.rehash)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), ctx: anytype) void`
    
Rehash the map, in-place. `pub fn remove[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.remove)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), key: K) bool`
    
If there is an `Entry` with a matching key, it is deleted from the hash map, and this function returns true. Otherwise this function returns false. `pub fn removeAdapted[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.removeAdapted)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), key: anytype, ctx: anytype) bool`
    
TODO: answer the question in these doc comments, does this increase the unused capacity by one? `pub fn removeByPtr[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.removeByPtr)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), key_ptr: *K) void`
    
Delete the entry with key pointed to by key_ptr from the hash map. key_ptr is assumed to be a valid pointer to a key that is present in the hash map. `pub fn removeContext[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.removeContext)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged), key: K, ctx: Context) bool`
    
TODO: answer the question in these doc comments, does this increase the unused capacity by one? `pub fn unlockPointers[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.unlockPointers)(self: *Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged)) void`
    
Undoes a call to `lockPointers`. `pub fn valueIterator[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.valueIterator)(self: Self[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged)) ValueIterator[](https://ziglang.org/documentation/master/std/#std.hash_map.HashMapUnmanaged.ValueIterator)`

## Error Sets
## Example Usage
## Source Code
# Keyboard Shortcuts 

`?`
    Show this help dialog 

`Esc`
    Clear focus; close this dialog 

`s`
    Focus the search field 

`u`
    Go to source code 

`↑`
    Move up in search results 

`↓`
    Move down in search results 

`⏎`
    Go to active search result
# Errors
