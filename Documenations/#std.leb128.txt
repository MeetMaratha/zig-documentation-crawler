[ ](https://ziglang.org/documentation/master/std/)
  * [std](https://ziglang.org/documentation/master/std/#std)
  * [leb128](https://ziglang.org/documentation/master/std/#std.leb128)


Loading...
# struct[[src]](https://ziglang.org/documentation/master/std/#src/std/leb128.zig)
## Parameters
## Errors
anyerror means the error set is known only at runtime.
## Search Results
## No Results Found
Press escape to exit search and then '?' to see more options.
## Fields
## Types
## Namespaces
## Global Variables
## Values
## Functions `pub fn readIleb128[](https://ziglang.org/documentation/master/std/#std.leb128.readIleb128)(comptime T: type, reader: anytype) !T`
    
Read a single signed LEB128 value from the given reader as type T, or error.Overflow if the value cannot fit. `pub fn readIleb128[](https://ziglang.org/documentation/master/std/#std.leb128.readIleb128)(comptime T: type, reader: anytype) !T`
    
Read a single signed LEB128 value from the given reader as type T, or error.Overflow if the value cannot fit. `pub fn readUleb128[](https://ziglang.org/documentation/master/std/#std.leb128.readUleb128)(comptime T: type, reader: anytype) !T`
    
Read a single unsigned LEB128 value from the given reader as type T, or error.Overflow if the value cannot fit. `pub fn readUleb128[](https://ziglang.org/documentation/master/std/#std.leb128.readUleb128)(comptime T: type, reader: anytype) !T`
    
Read a single unsigned LEB128 value from the given reader as type T, or error.Overflow if the value cannot fit. `pub fn writeIleb128[](https://ziglang.org/documentation/master/std/#std.leb128.writeIleb128)(writer: anytype, arg: anytype) !void`
    
Write a single signed integer as signed LEB128 to the given writer. `pub fn writeIleb128[](https://ziglang.org/documentation/master/std/#std.leb128.writeIleb128)(writer: anytype, arg: anytype) !void`
    
Write a single signed integer as signed LEB128 to the given writer. `pub fn writeSignedFixed[](https://ziglang.org/documentation/master/std/#std.leb128.writeSignedFixed)(comptime l: usize, ptr: *[l]u8, int: std[](https://ziglang.org/documentation/master/std/#std).meta[](https://ziglang.org/documentation/master/std/#std.meta).Int[](https://ziglang.org/documentation/master/std/#std.meta.Int)(.signed, l * 7)) void`
    
This is an "advanced" function. It allows one to use a fixed amount of memory to store an ILEB128. This defeats the entire purpose of using this data encoding; it will no longer use fewer bytes to store smaller numbers. The advantage of using a fixed width is that it makes fields have a predictable size and so depending on the use case this tradeoff can be worthwhile. An example use case of this is in emitting DWARF info where one wants to make a ILEB128 field "relocatable", meaning that it becomes possible to later go back and patch the number to be a different value without shifting all the following code. `pub fn writeUleb128[](https://ziglang.org/documentation/master/std/#std.leb128.writeUleb128)(writer: anytype, arg: anytype) !void`
    
Write a single unsigned integer as unsigned LEB128 to the given writer. `pub fn writeUleb128[](https://ziglang.org/documentation/master/std/#std.leb128.writeUleb128)(writer: anytype, arg: anytype) !void`
    
Write a single unsigned integer as unsigned LEB128 to the given writer. `pub fn writeUnsignedExtended[](https://ziglang.org/documentation/master/std/#std.leb128.writeUnsignedExtended)(slice: []u8, arg: anytype) void`
    
Same as `writeUnsignedFixed[](https://ziglang.org/documentation/master/std/#std.leb128.writeUnsignedFixed)` but with a runtime-known length. Asserts `slice.len > 0`. `pub fn writeUnsignedFixed[](https://ziglang.org/documentation/master/std/#std.leb128.writeUnsignedFixed)(comptime l: usize, ptr: *[l]u8, int: std[](https://ziglang.org/documentation/master/std/#std).meta[](https://ziglang.org/documentation/master/std/#std.meta).Int[](https://ziglang.org/documentation/master/std/#std.meta.Int)(.unsigned, l * 7)) void`
    
This is an "advanced" function. It allows one to use a fixed amount of memory to store a ULEB128. This defeats the entire purpose of using this data encoding; it will no longer use fewer bytes to store smaller numbers. The advantage of using a fixed width is that it makes fields have a predictable size and so depending on the use case this tradeoff can be worthwhile. An example use case of this is in emitting DWARF info where one wants to make a ULEB128 field "relocatable", meaning that it becomes possible to later go back and patch the number to be a different value without shifting all the following code.
## Error Sets
## Example Usage
## Source Code
# Keyboard Shortcuts 

`?`
    Show this help dialog 

`Esc`
    Clear focus; close this dialog 

`s`
    Focus the search field 

`u`
    Go to source code 

`↑`
    Move up in search results 

`↓`
    Move down in search results 

`⏎`
    Go to active search result
# Errors
