[ ](https://ziglang.org/documentation/master/std/)
  * [std](https://ziglang.org/documentation/master/std/#std)
  * [bounded_array](https://ziglang.org/documentation/master/std/#std.bounded_array)
  * [BoundedArray](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArray)


Loading...
# Type Function[[src]](https://ziglang.org/documentation/master/std/#src/std/bounded_array.zig)
A structure with an array and a length, that can be used as a slice.
Useful to pass around small arrays whose exact size is only known at runtime, but whose maximum size is known at comptime, without requiring an `Allocator`.
```
var actual_size = 32;
var a = try BoundedArray(u8, 64).init(actual_size);
var slice = a.slice(); // a slice of the 64-byte array
var a_clone = a; // creates a copy - the structure doesn't use any internal pointers

```

## Parameters
```
T: type
```

```
buffer_capacity: usize
```

## Errors
anyerror means the error set is known only at runtime.
## Search Results
## No Results Found
Press escape to exit search and then '?' to see more options.
## Fields
```
buffer: [buffer_capacity]T align(alignment.toByteUnits()) = undefined
```

```
len: usize = 0
```

## Types
  * [Writer](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned.Writer)


## Namespaces
## Global Variables
## Values
## Functions `pub fn addManyAsArray[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned.addManyAsArray)(self: *Self[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned), comptime n: usize) error{Overflow}!*align(alignment.toByteUnits()) [n]T`
    
Resize the slice, adding `n` new elements, which have `undefined` values. The return value is a pointer to the array of uninitialized elements. `pub fn addManyAsSlice[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned.addManyAsSlice)(self: *Self[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned), n: usize) error{Overflow}![]align(alignment.toByteUnits()) T`
    
Resize the slice, adding `n` new elements, which have `undefined` values. The return value is a slice pointing to the uninitialized elements. `pub fn addOne[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned.addOne)(self: *Self[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned)) error{Overflow}!*T`
    
Increase length by 1, returning a pointer to the new item. `pub fn addOneAssumeCapacity[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned.addOneAssumeCapacity)(self: *Self[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned)) *T`
    
Increase length by 1, returning pointer to the new item. Asserts that there is space for the new item. `pub fn append[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned.append)(self: *Self[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned), item: T) error{Overflow}!void`
    
Extend the slice by 1 element. `pub fn appendAssumeCapacity[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned.appendAssumeCapacity)(self: *Self[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned), item: T) void`
    
Extend the slice by 1 element, asserting the capacity is already enough to store the new item. `pub fn appendNTimes[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned.appendNTimes)(self: *Self[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned), value: T, n: usize) error{Overflow}!void`
    
Append a value to the slice `n` times. Allocates more memory as necessary. `pub fn appendNTimesAssumeCapacity[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned.appendNTimesAssumeCapacity)(self: *Self[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned), value: T, n: usize) void`
    
Append a value to the slice `n` times. Asserts the capacity is enough. `pub fn appendSlice[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned.appendSlice)(self: *Self[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned), items: []const T) error{Overflow}!void`
    
Append the slice of items to the slice. `pub fn appendSliceAssumeCapacity[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned.appendSliceAssumeCapacity)(self: *Self[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned), items: []const T) void`
    
Append the slice of items to the slice, asserting the capacity is already enough to store the new items. `pub fn capacity[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned.capacity)(self: Self[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned)) usize`
    
Return the maximum length of a slice. `pub fn clear[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned.clear)(self: *Self[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned)) void`
    
Remove all elements from the slice. `pub fn constSlice[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned.constSlice)(self: *const Self[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned)) []align(alignment.toByteUnits()) const T`
    
View the internal array as a constant slice whose size was previously set. `pub fn ensureUnusedCapacity[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned.ensureUnusedCapacity)(self: Self[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned), additional_count: usize) error{Overflow}!void`
    
Check that the slice can hold at least `additional_count` items. `pub fn fromSlice[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned.fromSlice)(m: []const T) error{Overflow}!Self[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned)`
    
Copy the content of an existing slice. `pub fn get[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned.get)(self: Self[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned), i: usize) T`
    
Return the element at index `i` of the slice. `pub fn init[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned.init)(len: usize) error{Overflow}!Self[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned)`
    
Set the actual length of the slice. Returns error.Overflow if it exceeds the length of the backing array. `pub fn insert[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned.insert)( self: *Self[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned), i: usize, item: T, ) error{Overflow}!void`
    
Insert `item` at index `i` by moving `slice[n .. slice.len]` to make room. This operation is O(N). `pub fn insertSlice[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned.insertSlice)(self: *Self[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned), i: usize, items: []const T) error{Overflow}!void`
    
Insert slice `items` at index `i` by moving `slice[i .. slice.len]` to make room. This operation is O(N). `pub fn orderedRemove[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned.orderedRemove)(self: *Self[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned), i: usize) T`
    
Remove the element at index `i`, shift elements after index `i` forward, and return the removed element. Asserts the slice has at least one item. This operation is O(N). `pub fn pop[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned.pop)(self: *Self[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned)) ?T`
    
Remove and return the last element from the slice, or return `null` if the slice is empty. `pub fn replaceRange[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned.replaceRange)( self: *Self[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned), start: usize, len: usize, new_items: []const T, ) error{Overflow}!void`
    
Replace range of elements `slice[start..][0..len]` with `new_items`. Grows slice if `len < new_items.len`. Shrinks slice if `len > new_items.len`. `pub fn resize[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned.resize)(self: *Self[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned), len: usize) error{Overflow}!void`
    
Adjust the slice's length to `len`. Does not initialize added items if any. `pub fn set[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned.set)(self: *Self[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned), i: usize, item: T) void`
    
Set the value of the element at index `i` of the slice. `pub fn slice[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned.slice)(self: anytype) switch (@TypeOf(&self.buffer)) { *align(alignment.toByteUnits()) [buffer_capacity]T => []align(alignment.toByteUnits()) T, *align(alignment.toByteUnits()) const [buffer_capacity]T => []align(alignment.toByteUnits()) const T, else => unreachable, }`
    
View the internal array as a slice whose size was previously set. `pub fn swapRemove[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned.swapRemove)(self: *Self[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned), i: usize) T`
    
Remove the element at the specified index and return it. The empty slot is filled from the end of the slice. This operation is O(1). `pub fn unusedCapacitySlice[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned.unusedCapacitySlice)(self: *Self[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned)) []align(alignment.toByteUnits()) T`
    
Return a slice of only the extra capacity after items. This can be useful for writing directly into it. Note that such an operation must be followed up with a call to `resize()` `pub fn writer[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned.writer)(self: *Self[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned)) Writer[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArrayAligned.Writer)`
    
Initializes a writer which will write into the array.
## Error Sets
## Example Usage
```
test BoundedArray {
  var a = try BoundedArray[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArray)(u8, 64).init(32);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(a.capacity(), 64);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(a.slice().len, 32);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(a.constSlice().len, 32);
  try a.resize(48);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(a.len, 48);
  const x = [_]u8{1} ** 10;
  a = try BoundedArray[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArray)(u8, 64).fromSlice(&x);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqualSlices[](https://ziglang.org/documentation/master/std/#std.testing.expectEqualSlices)(u8, &x, a.constSlice());
  var a2 = a;
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqualSlices[](https://ziglang.org/documentation/master/std/#std.testing.expectEqualSlices)(u8, a.constSlice(), a2.constSlice());
  a2.set(0, 0);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expect[](https://ziglang.org/documentation/master/std/#std.testing.expect)(a.get(0) != a2.get(0));
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectError[](https://ziglang.org/documentation/master/std/#std.testing.expectError)(error.Overflow, a.resize(100));
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectError[](https://ziglang.org/documentation/master/std/#std.testing.expectError)(error.Overflow, BoundedArray[](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArray)(u8, x.len - 1).fromSlice(&x));
  try a.resize(0);
  try a.ensureUnusedCapacity(a.capacity());
  (try a.addOne()).* = 0;
  try a.ensureUnusedCapacity(a.capacity() - 1);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(a.len, 1);
  const uninitialized = try a.addManyAsArray(4);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(uninitialized.len, 4);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(a.len, 5);
  try a.append(0xff);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(a.len, 6);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(a.pop(), 0xff);
  a.appendAssumeCapacity(0xff);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(a.len, 6);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(a.pop(), 0xff);
  try a.resize(1);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(a.pop(), 0);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(a.pop(), null);
  var unused = a.unusedCapacitySlice();
  @memset(unused[0..8], 2);
  unused[8] = 3;
  unused[9] = 4;
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(unused.len, a.capacity());
  try a.resize(10);
  try a.insert(5, 0xaa);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(a.len, 11);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(a.get(5), 0xaa);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(a.get(9), 3);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(a.get(10), 4);
  try a.insert(11, 0xbb);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(a.len, 12);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(a.pop(), 0xbb);
  try a.appendSlice(&x);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(a.len, 11 + x.len);
  try a.appendNTimes(0xbb, 5);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(a.len, 11 + x.len + 5);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(a.pop(), 0xbb);
  a.appendNTimesAssumeCapacity(0xcc, 5);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(a.len, 11 + x.len + 5 - 1 + 5);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(a.pop(), 0xcc);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(a.len, 29);
  try a.replaceRange(1, 20, &x);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(a.len, 29 + x.len - 20);
  try a.insertSlice(0, &x);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(a.len, 29 + x.len - 20 + x.len);
  try a.replaceRange(1, 5, &x);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(a.len, 29 + x.len - 20 + x.len + x.len - 5);
  try a.append(10);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(a.pop(), 10);
  try a.append(20);
  const removed = a.orderedRemove(5);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(removed, 1);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(a.len, 34);
  a.set(0, 0xdd);
  a.set(a.len - 1, 0xee);
  const swapped = a.swapRemove(0);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(swapped, 0xdd);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(a.get(0), 0xee);
  const added_slice = try a.addManyAsSlice(3);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(added_slice.len, 3);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqual[](https://ziglang.org/documentation/master/std/#std.testing.expectEqual)(a.len, 36);
  while (a.pop()) |_| {}
  const w = a.writer();
  const s = "hello, this is a test string";
  try w.writeAll(s);
  try testing[](https://ziglang.org/documentation/master/std/#std.testing).expectEqualStrings[](https://ziglang.org/documentation/master/std/#std.testing.expectEqualStrings)(s, a.constSlice());
}
```

## Source Code
# Keyboard Shortcuts 

`?`
    Show this help dialog 

`Esc`
    Clear focus; close this dialog 

`s`
    Focus the search field 

`u`
    Go to source code 

`↑`
    Move up in search results 

`↓`
    Move down in search results 

`⏎`
    Go to active search result
# Errors
